<!DOCTYPE html>
<html>
<head>

    <style>
        body { font-family: sans-serif; padding: 1rem; }
        h1 { text-decoration: underline}
        summary { margin-top: 2rem; font-size: 1.5rem; font-weight: bold; }
        pre { background: #eee; padding: 1rem; max-height: 500px; overflow-y: auto; }
        button { margin-left: 0.5rem; padding: 0.5rem 1rem; cursor: pointer; }
        input { width: 350px; padding: 0.5rem; }
        .connection-control { margin-bottom: 1rem; }
    </style>
    <script>
        class Queue {
            constructor(limit = 10) {
                this.limit = limit;
                this.items = [];
            }

            enqueue(item) {
                // Add to queue
                this.items.push(item);

                // Keep only the last 'limit' items
                if (this.items.length > this.limit) {
                    this.items.shift(); // remove oldest
                }
            }

            getReversed() {
                // Return newest â†’ oldest
                return [...this.items].reverse();
            }
        }
    </script>
</head>
<body>
    <h1>Braude Project 2025 - Nimbus</h1>
    <h4>Created by Shlomi Fridman and Shahar Berenson</h4>
    <br>

    <h2>Connection Status</h2>
    <div class="connection-control">
        <label for="wsAddress">WebSocket URL:</label>
        <input id="wsAddress" type="text" value="wss://braudeproject2025server.onrender.com/" placeholder="Enter WebSocket URL" />
        <button id="connectBtn">Connect</button>
        <button id="toggleBtn">Switch to localhost</button>
    </div>
    <pre id="statusPre">Waiting for status...</pre>


    <details open>
        <summary>Current System Status</summary>
        <pre id="currSSMessages">Waiting for message...</pre>
    </details>

    <details>
        <summary>Mqtt Messages</summary>
        <pre id="mqttPre">Waiting for messages...</pre>
    </details>

    <details>
        <summary>System Status Messages</summary>
        <pre id="ssMessages">Waiting for messages...</pre>
    </details>

    <script>
        // Connect to your WebSocket server
        const REMOTE_URL = 'wss://braudeproject2025server.onrender.com/';
        const LOCAL_URL = 'ws://localhost:5000/';
        const statusPre = document.getElementById('statusPre');
        const mqttPre = document.getElementById('mqttPre');
        const ssPre = document.getElementById('ssMessages');
        const currSSPre = document.getElementById('currSSMessages');
        const toggleBtn = document.getElementById('toggleBtn');
        const connectBtn = document.getElementById('connectBtn');
        const wsAddressInput = document.getElementById('wsAddress');

        const mqttQueue = new Queue(100);
        const ssQueue = new Queue(100);

        let currentUrl = REMOTE_URL;
        let ws;

        function connectWebSocket(url) {
            if (ws) ws.close(1000, "Manual disconnect");

            statusPre.textContent = 'Connecting to ' + url + ' ...';
            ws = new WebSocket(url);

            ws.onopen = () => {
                console.log('Connection opened (' + ws.url + ')');
                statusPre.textContent = 'Connected to ' + url;
                ws.send("system_status");
                ws.send("log");
                ws.send("mqtt");
            };

            ws.onmessage = (event) => {
                // console.log('Message from server:', event.data);
                let data = event.data;
                try { data = JSON.parse(data); } catch {}
                if (data.topic === 'system_status'){
                    currSSPre.textContent = JSON.stringify(data.message, null, 2);
                    ssQueue.enqueue(data.message)
                    prependMessage(ssPre, ssQueue);
                }
                else if (data.topic === 'mqtt'){
                    mqttQueue.enqueue(data.message)
                    prependMessage(mqttPre, mqttQueue);
                }
            };

            // ws.onclose = () => {
            //     console.log('Connection closed (' + ws.url + ')');
            //     // statusPre.textContent = 'Connection closed (' + url + ')';
            // };

            ws.onerror = (err) => {
                console.error('WebSocket error:', err);
                statusPre.textContent = 'Connection error to ' + currentUrl;
            };
        }

        function prependMessage(pre, queue) {
            const items = queue.getReversed();
            const text = items.map(tmp => JSON.stringify(tmp, null, 2)).join('\n---------------------------------------\n');
            if (pre.textContent === 'Waiting for messages...') pre.textContent = '';
            pre.textContent = text;
        }

        toggleBtn.addEventListener('click', () => {
            console.error('WebSocket trying to disconnected');
            ws.close(1000, "Manual disconnect")

            if (currentUrl === REMOTE_URL) {
                currentUrl = LOCAL_URL;
                wsAddressInput.value = LOCAL_URL;
                toggleBtn.textContent = 'Switch to remote';
            } else {
                currentUrl = REMOTE_URL;
                wsAddressInput.value = REMOTE_URL;
                toggleBtn.textContent = 'Switch to localhost';
            }
            ws = null;
            connectWebSocket(currentUrl);
        });

        // Connect initially to remote server
        connectBtn.addEventListener('click', () => {
            const url = wsAddressInput.value.trim();
            if (!url) {
                alert('Please enter a WebSocket URL.');
                return;
            }
            connectWebSocket(url);
        });

        // Auto-connect to default URL
        connectWebSocket(wsAddressInput.value);


    </script>
</body>
</html>
